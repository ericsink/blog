<html>
<head>
<title>{{{site.title}}}</title>
<style type="text/css">
.SiteTitle {font-family: Arial, Helvetica, sans-serif; font-size:36pt}
.Tagline {font-family: Arial, Helvetica, sans-serif; font-style:italic}
.ArticleTitle {text-decoration: none; color: black; font-family: Arial, Helvetica, sans-serif; font-weight:bold; font-size:18pt}
.DayPageArticleTitle {text-decoration: none; color: black; font-family: Arial, Helvetica, sans-serif; font-weight:bold; font-size:12pt}
.ArticleDate {font-size:8pt;font-weight:normal}
.LeftSide {font-family: Arial, Helvetica, sans-serif; font-size:10pt}
.ArticleBlurbCell {background:#cccccc; color:#000000; font-family: Arial, Helvetica, sans-serif}
.Copyright { font-size:7pt }
</style>
</head>
<body>
<P><span class="SiteTitle">{{{site.title}}}</span><br><span class="Tagline">{{{site.tagline}}}</span></p>
<h2>The .NET Abstraction Pile</h2>
<font size=2>22 Apr 2003</font><p>

<HTML xmlns:o = "urn:schemas-microsoft-com:office:office">



<P>An abstraction is a boundary with two sides.&nbsp; On the top side, the 
abstraction presents a simplified view.&nbsp;&nbsp;Below, there&nbsp;is 
something more complex and more real.&nbsp; The purpose of the abstraction is to 
obscure what is really going on.</P>
<P>The world hidden underneath an abstraction is quite likely to be yet another 
abstraction.&nbsp; In fact, it is typical to have many abstractions stacked 
together, each one attempting to present an illusion which is even further from 
the truth.&nbsp; If you stack them up vertically, the ones at the bottom are 
more <EM>real</EM> than the ones at the top.</P>
<P>This is what programmers do.&nbsp; We build piles of abstractions.&nbsp; We 
design our own abstractions and then pile them up on top of layers we got from 
somebody else.&nbsp; Abstractions can be great.&nbsp; We use them because they 
save us a lot of time.&nbsp; But abstractions can also cause lots of 
problems.&nbsp; They're never perfect, as Joel Spolsky explains in his excellent 
article on "<A 
href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">The Law of 
Leaky Abstractions</A>".</P>
<P>But you can't have the benefits of an abstraction without&nbsp;its 
risks.&nbsp; We need to make wise decisions about our piles of 
abstractions.&nbsp;&nbsp;I'll start by offering&nbsp;three rules to keep in 
mind:</P>
<P><FONT face=Arial,Helvetica,sansserif size=4>Abstractions contain 
bugs.</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P>Using somebody else's code&nbsp;can save a lot of time.&nbsp; For example, 
  a special GUI component allows you to program at a higher level of 
  abstraction.&nbsp; Why write your own?</P>
  <P>You have to remember that you are accepting a tradeoff.&nbsp; By using 
  somebody else's code you are inheriting somebody else's bugs.&nbsp; Often you 
  are accepting risks that are not under your control.</P></BLOCKQUOTE>
<P><FONT face=Arial,Helvetica,sansserif size=4>Abstractions reduce 
performance.</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P><FONT face="Times New Roman,Times,serif">Writing in Java is faster than 
  writing in C.&nbsp; But C code runs much faster than Java code.&nbsp; It's a 
  tradeoff that you cannot avoid.&nbsp; All you can do is make the right 
  choice.</FONT></P></BLOCKQUOTE>
<P><FONT face=Arial,Helvetica,sansserif size=4>Abstractions increase overall 
complexity.</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P><FONT face="Times New Roman,Times,serif">The goal of each abstraction is to 
  decrease complexity by presenting a simplified view of something else.&nbsp; 
  However, by the time you pile them all up, you've got a lot of complexity 
  which you may have to deal with.&nbsp; In fact, the more layers of abstraction 
  you have, the more complexity you've got involved.</FONT></P></BLOCKQUOTE>
<P><FONT face=Arial,Helvetica,sansserif size=5><STRONG>A Really Tall 
Pile</STRONG></FONT></P>
<P>Let's work through an example.&nbsp; Suppose that I am working from my home 
and I am ready to checkin some really important code changes to a source code 
file.&nbsp; I'm using the SourceGear Vault client to connect to our server back 
at SourceGear's main office.&nbsp; Below is a list of [almost] all the 
abstractions which are in play.<o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Vault</STRONG>.&nbsp; 
  The version control system itself is an abstraction.&nbsp; It presents our 
  users with concepts like Check Out, Check In, Label, Branch, Pin and 
  Share.&nbsp; This layer is obviously very important, since it's the only one 
  we can charge money for.&nbsp;<img src="smiley.gif"><o:p></o:p></LI></OL>
<P><STRONG><SPAN style="FONT-SIZE: 13.5pt; FONT-FAMILY: Arial">Control 
Flow:</SPAN></STRONG><o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1 start=2>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>C#</STRONG>.&nbsp; 
  Vault is written entirely in C#, which is a very nice abstraction 
  indeed.&nbsp; From C#&nbsp;we get&nbsp;classes, objects, methods, <A 
  href="http://www.joelonsoftware.com/articles/fog0000000319.html">strings</A>, 
  looping constructs, logical operators, and the ability to attach names to 
  things.&nbsp; Cool.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>CLR</STRONG>.&nbsp; 
  C# runs on the Common Language Runtime, which&nbsp;is a huge 
  abstraction.&nbsp; In fact, if we all weren't so worried about comparing .NET 
  to Java we would be calling the CLR a "virtual machine", which it 
  is.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>C++</STRONG>.&nbsp; 
  The CLR is written in lower level languages like C++ and C. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Assembly</STRONG>.&nbsp; 
  C++ is implemented by compiling it to x86 assembler code.&nbsp; We've taken a 
  big, big jump here.&nbsp; Compared to C++, assembly language doesn't feel very 
  abstract at all. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Microcode</STRONG>.&nbsp; 
  Did you think Assembly was the lowest level of programming?&nbsp; Certainly 
  not.&nbsp; Each x86 assembler instruction is a little program written in an 
  even lower level language called microcode. <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Logical 
  gates</STRONG>.&nbsp; Microcode is implemented by circuits which provide 
  logical gates, including NOT, AND, OR, and NAND. <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Transistors</STRONG>.&nbsp;Logical 
  gates are implemented by transistors, an electronic component with three wires 
  sticking out of it.<o:p></o:p></LI></OL>
<P><STRONG><SPAN 
style="FONT-SIZE: 13.5pt; FONT-FAMILY: Arial">Memory:</SPAN></STRONG><o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1 start=9>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>ArrayList</STRONG>.&nbsp; 
  The .NET framework gives us "collections" we can use to manage memory in 
  aggregated ways.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Objects</STRONG>.&nbsp; 
  From the realm of OOP we get "objects", self-contained pieces of data which 
  are bound to the operations which can be performed on that data.&nbsp; Very 
  handy.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>GC</STRONG>.&nbsp; 
  This is a big one.&nbsp; Because the .NET Common Language Runtime has a 
  garbage collector, we can create objects and know that they will automatically 
  be destroyed later when we are done with them. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Handles</STRONG>.&nbsp; 
  In reality, memory has to be explicitly requested and released from 
  the&nbsp;operating system.&nbsp; Each chunk of memory is identified by a 
  handle.&nbsp;<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Virtual 
  Memory</STRONG>.&nbsp; This layer gives us another important illusion:&nbsp; 
  There is more memory available than we actually have.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>RAM</STRONG>.&nbsp; 
  Random Access Memory is itself an abstraction.&nbsp;&nbsp;Transistors don't 
  really remember anything.&nbsp; Furthermore, the notion of a bit doesn't 
  really exist.&nbsp;&nbsp;&nbsp; We simply assign conventions.&nbsp; When a 
  wire is at 5V, we call it a one.&nbsp; When it has no voltage on it, we call 
  it a zero.&nbsp; Collect a few hundred million of these in one place and 
  you've got a DIMM.&nbsp; <EM>(Actually, it's 3.3V nowadays, 
right?)</EM></LI></OL>
<P><STRONG><SPAN style="FONT-SIZE: 13.5pt; FONT-FAMILY: Arial">The Check In 
Button:</SPAN></STRONG><o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1 start=15>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Button</STRONG>.&nbsp; 
  The Check In dialog has a button on it.&nbsp; When the user presses this 
  button, the Check In operation will commence.&nbsp; But the button itself is 
  an abstraction.&nbsp; It is designed to simulate the concept of a physical 
  button like you might find on your microwave or TV.&nbsp; No such button 
  really exists.&nbsp; Windows Forms provides this abstraction. <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>HWND</STRONG>.&nbsp; 
  Windows Forms is a layer of abstraction which is built on the Win32 API 
  underneath.&nbsp; The button is actually a window with its own WndProc.&nbsp; 
  .NET tries to hide this world, but it's definitely still there.&nbsp; One of 
  the glaring "leaks" in the Windows Forms abstraction is the absence of the 
  Win32 ScrollWindow() call. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>GDI</STRONG>.&nbsp; 
  The button is actually drawn using graphics primitives from GDI.&nbsp; It 
  doesn't just magically appear.&nbsp; It needs to be drawn using things like 
  DrawRect, fonts and colors. <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Pixels</STRONG>.&nbsp; 
  GDI contains primitives like DrawLine, but these are implemented in terms of 
  pixels.&nbsp; Graphics primitives are actually not quite so primitive.&nbsp; 
  If you think line drawing is easy, look up <A 
  href="http://www.google.com/search?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=bresenham&amp;spell=1">Bresenham</A>. 
  <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Video 
  Card</STRONG>.&nbsp; The pixels are actually an abstraction presented&nbsp;by 
  a video card. <o:p></o:p>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Monitor</STRONG>.&nbsp; 
  The monitor presents the illusion that all those pixels are organized into 
  pictures and images.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Light</STRONG>.&nbsp; 
  I stop whenever I get to Physics or Chemistry.&nbsp; For my purposes, light is 
  real, not an abstraction.<o:p></o:p></LI></OL>
<P><STRONG><SPAN style="FONT-SIZE: 13.5pt; FONT-FAMILY: Arial">Architecture of 
the Vault Client:</SPAN></STRONG><o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1 start=22>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>VaultClientPresentationLib</STRONG>.&nbsp; 
  We wrote this layer as part of Vault.&nbsp; It contains all the windows and 
  dialog boxes necessary to create the Vault GUI client.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>VaultClientOperationsLib</STRONG>.&nbsp; 
  This layer is a big part of Vault.&nbsp; It contains basic non-GUI primitives 
  which are necessary to write a Vault client.&nbsp; Create an instance of the 
  ClientInstance class.&nbsp; The methods on this class will communicate with 
  the Vault server and simultaneously keep your local working folder updated. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>VaultClientNetLib</STRONG>.&nbsp; 
  The previous layer actually calls VaultClientNetLib to communicate with the 
  Vault server.&nbsp; This layer is fairly thin.&nbsp; It is mostly a wrapper 
  around the Proxy Class. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Proxy 
  Class</STRONG>.&nbsp; This important layer is generated by Visual Studio 
  .NET.&nbsp; It presents the illusion that&nbsp;the XML Web Service on the 
  Vault server is actually a C# class.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>SOAP</STRONG>.&nbsp; 
  When a call is made through the proxy class, the parameters for that call are 
  bundled up in <A 
  href="http://msdn.microsoft.com/library/default.asp?url=/nhp/Default.asp?contentid=28000523">SOAP</A> 
  format.&nbsp; This format presents the concept of a method invocation message. 

  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>XML</STRONG>.&nbsp; 
  SOAP is built on XML, a syntax framework for representing data. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>HTTP</STRONG>.&nbsp; 
  The SOAP message is transported to the server over <A 
  href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP</A>, the 
  networking protocol on which the Web is built. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>DNS</STRONG>.&nbsp; 
  The Vault user types the <EM>name</EM> of the server, but that name isn't 
  really useful.&nbsp; It has to be converted to an IP address before real 
  network communication can take place.&nbsp; The Domain Name System is used to 
  look behind the abstract name and get the actual machine address. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>SSL</STRONG>.&nbsp; 
  The Secure Sockets Layer offers the illusion that communication over the 
  Internet can be private.&nbsp; This layer tries to look just like a regular 
  socket, except all of the data is encrypted as it passes through to/from the 
  socket itself.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Sockets</STRONG>.&nbsp; 
  This layer is a great abstraction.&nbsp; Sockets present us with the illusion 
  of connections and the ability to send and receive data between endpoints. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>TCP</STRONG>.&nbsp; 
  The basic illusion of TCP is the idea that packets of data will arrive and in 
  fact, will arrive in the order they were sent.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>IP</STRONG>.&nbsp; 
  TCP is built on IP, which is even lower level network protocol.&nbsp; At this 
  layer, packets may or may not actually arrive, and they may arrive in a 
  different order than how they were sent.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Ethernet</STRONG>.&nbsp; 
  The&nbsp;IP packets are carried on a cat5 wire sticking out the back of my 
  computer.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Radio</STRONG>.&nbsp; 
  The Internet connection at my home is a <A 
  href="http://www.prairieinet.com/">wireless</A> antenna pointed at the top of 
  a grain elevator eight miles away.&nbsp; So right now, the important code 
  change I am trying to checkin is a bunch of radio signals which represent 
  packets that may or may not arrive, but they are flying through the air, 25 
  feet above a corn field.<o:p></o:p></LI></OL>
<P><STRONG><SPAN style="FONT-SIZE: 13.5pt; FONT-FAMILY: Arial">Architecture of 
the Vault Server:</SPAN></STRONG><o:p></o:p></P>
<OL style="MARGIN-TOP: 0in" type=1 start=36>
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>VaultService.asmx</STRONG>.&nbsp; 
  The Vault server is an XML Web Service.&nbsp; This allows us to think of our 
  server as a collection of methods which will invoked in an "RPC-like" 
  fashion.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>ASP.NET</STRONG>.&nbsp;&nbsp;The 
  illusion of XML Web Services is actually provided by ASP.NET. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>VaultServiceSQL</STRONG>.&nbsp; 
  This library provides a wrapper which insulates the rest of the server from 
  having to know anything about SQL.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Stored 
  Procs</STRONG>.&nbsp; This layer is a collection of stored procedures running 
  inside SQL Server. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>SQL</STRONG>.&nbsp; 
  The SQL language is an enormous abstraction.&nbsp; It presents concepts like 
  tables, rows and indices, as well as atomic transactions.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>IO 
  calls</STRONG>.&nbsp; Somewhere deep inside SQL Server 2000 is the place where 
  data is actually written to the disk file.&nbsp; They probably call the native 
  Win32 IO calls. 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>NTFS</STRONG>.&nbsp; 
  The filesystem is a very important abstraction.&nbsp; It presents the concept 
  of files and folders, as well as permissions and attributes.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Partitions</STRONG>.&nbsp; 
  The filesystem exists on a "partition", which is a portion of the space on a 
  hard disk.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>RAID 
  array</STRONG>.&nbsp; The RAID controller presents the illusion of one hard 
  disk&nbsp;when it is actually several.<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Hard 
  disk</STRONG>.&nbsp; In practical terms, this was the goal of the checkin all 
  along.&nbsp; My bits are finally stored in my hard disk.&nbsp; But the disk 
  itself is actually an abstraction...<o:p></o:p> 
  <LI class=MsoNormal 
  style="MARGIN: 6pt 0in 0pt; mso-margin-bottom-alt: auto; mso-list: l3 level1 lfo8; tab-stops: list .5in"><STRONG>Platters</STRONG>.&nbsp; 
  The term "hard disk" sounds singular, but hard disks today usually have 
  several platters inside.&nbsp; These platters are the magnetic media where the 
  data actually resides.<o:p></o:p></LI></OL>
<P>So there you have it -- 46 layers of abstraction which are all involved when 
I try to checkin my code.&nbsp; That means there are&nbsp;46 layers in which 
something might go wrong.</P>
<P>Actually the truth is that several of&nbsp;these abstractions are almost 
perfect.&nbsp; For example, I've actually never had to worry about the layer 
between <STRONG>Assembly</STRONG> and <STRONG>Microcode</STRONG>.&nbsp; As far 
as I am concerned, <STRONG>Assembly</STRONG> is an abstraction that always Just 
Works.</P>
<P>But it would be terribly wrong to ignore all those layers.&nbsp; Yes, 
SourceGear's implementation of Vault required us to only write the code for a 
few of the layers above.&nbsp; However, when it's time for QA and Tech Support, 
all 46 layers are fully in play.&nbsp; Stuff Happens.&nbsp; When a customer has 
a problem with Vault, the actual problem could be almost anywhere.&nbsp; We have 
to figure out what's gone wrong, even if it's in one of the layers we didn't 
create.&nbsp; Ask our tech support team how often layer 29 causes trouble.<img src="smiley.gif">
</P>
<P><FONT face=Arial,Helvetica,sansserif size=5><STRONG>How to Kill Your 
Project</STRONG></FONT></P>
<P>When you build software, you're going to end up making a lot of decisions 
about abstractions:</P>
<UL>
  <LI>Which abstractions do you want to build on? 
  <LI>Where will you get the implementations of those abstractions (platforms, 
  libraries, components)? 
  <LI>How trustworthy are those implementations?</LI></UL>
<P>You have lots of alternatives.&nbsp; For example, you can often make a 
tradeoff by choosing to work at a lower level of abstraction.&nbsp; By doing so, 
your development process will move more slowly, but more of the risks will be 
under your control.&nbsp; For example, if I had a really small magnet and really 
fine motor control skills, I could skip layers 1 through 45, drive to my office 
and modify those platters myself.&nbsp;<img src="smiley.gif"> </P>
<P>The stakes are higher than you might think.&nbsp; You can kill your project 
by making the wrong decisions about abstractions.&nbsp; Do you remember the word 
processor called WriteNow?&nbsp; This product was my favorite word processor 
back when I was a Macintosh fanatic.&nbsp;&nbsp;WriteNow was really fast and had 
just the right mix of features.</P>
<P>Today, WriteNow is <A 
href="http://www.macease.com/writenow-latest_info.html">dead</A> because 
somebody got burned by the decisions they made regarding abstractions.&nbsp; You 
see, WriteNow was really fast because it was written in 68000 assembly 
language.&nbsp; When Apple moved the Macintosh product line to the PowerPC, 
WriteNow had nowhere to go.</P>
<P>These choices are hard, and learning from your mistakes is an excellent (but 
painful) way to learn.&nbsp; But over the years, I've gathered the following 
guidelines which help me make abstraction-related decisions:</P><FONT 
face=Arial,Helvetica,sansserif size=4>
<P><FONT face=Arial,Helvetica,sansserif size=4>Consider your context.</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P><FONT face="Times New Roman,Times,serif" size=3>Developing a server 
  operating system is different from developing an web-based HR application so 
  employees can check their vacation days.&nbsp; There is no formula which works 
  well for all kinds of projects.&nbsp; You need to understand what kinds of 
  risks are appropriate for the kind of software you are trying to 
  build.</FONT></P>
  <P><FONT face="Times New Roman" size=3>As a general rule, developers of 
  internal corporate applications tend to use more third party components than 
  ISVs.&nbsp; If you're writing code for the IT department of a company whose 
  primary business is not software, then your salary is an expense, not an 
  investment.&nbsp; Your employer wants you to get the app done FAST, because it 
  costs less to get it done that way.&nbsp; Corporate IT developers want every 
  decent abstraction they can get.</FONT></P>
  <P><FONT face="Times New Roman" size=3>ISVs like SourceGear face a different 
  set of problems.&nbsp; If a third-party component brings even a 
  minor&nbsp;loss of quality to the app, it can severely affect our sales as 
  prospective customers look at our competitors.&nbsp; But that same competition 
  is tugging you in the other direction, reminding you that time-to-market can 
  be critical.&nbsp; Using third-party apps may be the only way to get your 
  product to market within the window of opportunity, but the risks need to be 
  studied closely.</FONT></P>
  <P><FONT face="Times New Roman" size=3>The size of your company should affect 
  your choices as well.&nbsp; Nothing is more frustrating than being unable to 
  ship a product because of a bug that you can't fix because it's in a 
  third-party library.&nbsp; For a very small company, the financial damage of a 
  situation like this can be severe.&nbsp; These are the times when you wish you 
  had chosen to put more of your risks inside your own circle of 
  control.</FONT></P></BLOCKQUOTE>
<P>Place your trust carefully.</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P><FONT face="Times New Roman,Times,serif">I recommend approaching third 
  party code with a great deal of suspicion.&nbsp; Never assume that an unknown 
  component or platform will Just Work.&nbsp; A little paranoia will probably 
  pay off later.</FONT></P>
  <P>When picking the pieces of your platform, as a general rule, "older is 
  better".&nbsp; You can walk with less worry on a path which has been well 
  trodden by many people for years.&nbsp;&nbsp;As an extremely 
  obvious&nbsp;example, C is old and mature enough to be a platform which will 
  yield very few surprises.</P>
  <P>Evaluating newer technologies is harder.&nbsp; Try to figure out who else 
  is using the abstraction successfully.&nbsp; Grab the technology and take it 
  for a test drive.&nbsp; In the end, you may not get enough evidence to lead to 
  a completely confident decision.&nbsp; If you really need the convenience 
  offered by the abstraction, you may have to jump out with a little 
faith.</P></BLOCKQUOTE>
<P><FONT face=Arial,Helvetica,sansserif size=4>Learn to see through the 
abstractions.&nbsp; </FONT></P><FONT face=Arial size=5>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P><FONT face="Times New Roman,Times,serif" size=3>The&nbsp;most important 
  point in this whole article is this:&nbsp; You need to understand what's going 
  on inside all your abstraction layers.&nbsp; Each abstraction presents an 
  illusion, but the best decisions happen when you can see <EM>through</EM> the 
  illusion.</FONT></P>
  <P><FONT face="Times New Roman" size=3>If you have a deep understanding of all 
  the technology abstractions that are involved with your software, then you 
  have two big advantages:</FONT></P>
  <BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
    <P dir=ltr style="MARGIN-RIGHT: 0px"><FONT face="Times New Roman" size=3>You 
    can quickly isolate problems.</FONT></P>
    <P dir=ltr style="MARGIN-RIGHT: 0px"><FONT face="Times New Roman" size=3>You 
    can develop an intuition which will help you avoid those problems in the 
    first place.</FONT></P></BLOCKQUOTE>
  <P><FONT face="Times New Roman,Times,serif" size=3>The first point is fairly 
  obvious.&nbsp; Troubleshooting goes much better when you know what's going 
  on.&nbsp; Have you ever watched someone try to solve a problem in the presence 
  of several abstractions they didn't understand?&nbsp; They feel 
  helpless.&nbsp; Usually, they start making wild guesses about where the 
  problem could be.&nbsp; I call this "stab in the dark debugging".&nbsp;<img src="smiley.gif">
  </FONT></P>
  <P><FONT face="Times New Roman" size=3>More importantly, if you can see 
  through most abstractions then you can develop an intuition to make much 
  better technology decisions.&nbsp; Choosing the right libraries and components 
  in your platform can prevent lots of problems before they ever 
  happen.</FONT></P>
  <P><FONT face="Times New Roman,Times,serif" size=3>Don't assume that this kind 
  of deep technical knowledge becomes less valuable as you climb the management 
  ladder.&nbsp; Understanding this stuff can be a huge advantage in many kinds 
  of decisions, right up to the most executive levels.&nbsp; I believe the 
  technical prowess of Bill Gates was a major reason why Microsoft beat every 
  competitor in the eighties and nineties, even though Bill probably wrote no 
  code, no specs, and no design documents.</FONT></P></BLOCKQUOTE>
<P><STRONG>Failures and Successes</STRONG></FONT></P>
<P>It wouldn't be fair to only mention the mistakes of others when I've made so 
many excellent and instructive mistakes of my own.&nbsp;<img src="smiley.gif"> </P>
<P>My most recent blunders in this area happened when we built <A 
href="http://www.sourcegear.com/collab/">SourceOffSite Collab </A>on a pile of 
abstractions which was way too short.</P>
<UL>
  <LI>We built our own implementation of the "server pages" concept because ASP 
  didn't meet our requirements <EM>perfectly</EM>.&nbsp; Collab includes its own 
  web server which processes pages we call "giglets".&nbsp; In between the &lt;% 
  and %&gt; we process JavaScript using the <A 
  href="http://www.mozilla.org/js/spidermonkey/">Mozilla engine</A> which has 
  been modified with special Collab-specific hooks.&nbsp; In retrospect, we 
  should have found a way to work around the limitations of Microsoft's standard 
  dynamic page generation technology.<BR>
  <LI>We also implemented a complete system for XML-based procedure calls.&nbsp; 
  We&nbsp;rationalized this one&nbsp;because <A 
  href="http://www.xmlrpc.com/">XML-RPC</A> and SOAP just weren't quite 
  <EM>perfect</EM> for our needs.&nbsp; Hindsight now brings us to the same 
  conclusion as above -- changing our requirements to fit the established 
  platforms would have been the wiser choice.</LI></UL>
<P>Better decisions would have gotten SOS Collab to market sooner and we would 
have fewer code maintenance problems now.</P>
<P>Not all of our decisions went badly.&nbsp; We made a great choice when we 
decided to build Vault using .NET.</P>
<P>From the beginning, I hoped that .NET was "Java done right".&nbsp; I've used 
Java extensively, and I loved the productivity gains we got during the beginning 
and middle of the development cycle.&nbsp; But things got ugly at the end.&nbsp; 
All those layers of abstraction started contributing to our bug list.&nbsp; I've 
been involved in a couple of projects which completely failed because Java was 
chosen.&nbsp; <EM>(Yes, this is merely my opinion, and yes, there were other 
factors in the failure of those projects.)</EM></P>
<P>Given our bad experiences with Java, our decision to use .NET took a fair 
amount of courage.&nbsp; Early experiments looked promising, but we knew that we 
would have to wait for the endgame to really know if .NET could really be 
trusted all the way through.</P>
<P>As I write this, <A href="http://www.sourcegear.com/vault/">SourceGear Vault 
</A>1.0 has been shipping for over two months.&nbsp; We have no regrets.&nbsp; 
For an abstraction pile as large as the one described above, it's remarkable 
that&nbsp;this product&nbsp;works at all.&nbsp;<img src="smiley.gif"></P>
<P>But the fact that it works <EM>well</EM> is nothing short of amazing.&nbsp; 
We have test applications which continuously try to abuse Vault in ways that are 
abusive and profane.&nbsp; If something goes wrong in <EM>any</EM> layer of 
abstraction, the whole test will come to a halt.&nbsp; But we can let these 
tests run for days at a time without any problems whatsoever.</P>
<P>This success stands as a testimony to how incredible .NET really is.&nbsp; We 
built a reasonably full-featured version control system in 14 months, and it 
works.&nbsp; Sure, we had some trouble.&nbsp; Layers 25, 37 and 40 didn't always 
behave like they should.&nbsp; But layer 11 was problem-free, quite unlike its 
Java counterpart.&nbsp; Considering the productivity gains we received, I never 
expected things to go so smoothly.</P>
<P><EM>Note:&nbsp; In response to the controversy generated by this article, I 
posted some <A href="http://software.ericsink.com/Pile_Followups.html">followup 
remarks</A>.</EM></P>
<P>
<P><span class="Copyright">{{{site.copyright}}}</span></P>
</body></html>
