---
layout: post
esbma_id: 1564
title: My life as a Code Economist
date: 2005-11-11 15:54:58
keywords: dev
---
<p>The six billion people of the world can be divided into two
groups:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li >People who know why every good software company ships
     products with known bugs.</li>
 <li >People who don't.</li>
</ol>

<p>Those of us in group 1 tend to forget what life was like
before our youthful optimism was spoiled by reality.&nbsp; Sometimes we encounter a
person in group 2, perhaps a new hire on the team or even a customer.&nbsp; They are
shocked that any software company would ever ship a product before every last
bug is fixed.&nbsp; </p>

<p>Every time Microsoft releases a new version of Windows,
major news services carry a story about the fact that the open bug count is a
five digit number.&nbsp; People in group 2 find that sort of thing interesting.</p>

<p>The surprising truth is that a person in group 2 can lead a
productive life.&nbsp; In fact, as with most any other kind of ignorance, they're
probably happier that way.</p>

<p>The exception of course is if you are a software developer.&nbsp;
That's an entirely different story.&nbsp; If you earn your living building
shrinkwrap software products, you need to get yourself in group 1.&nbsp; </p>

<p>Perhaps, dear reader, you are a software developer in group
2?&nbsp; If so, I'm sorry I had to be the one to tell you this.&nbsp; I feel like I'm
telling the neighbor kid that Santa Claus isn't real.&nbsp; <b>:-)</b></p>

<p>Okay, seriously.&nbsp; I apologize for the mock arrogance of the
previous paragraphs, and for the Santa Claus remark.&nbsp; I mean no condescension.&nbsp;
Just like everybody else, I've got lots to learn.&nbsp; But I've also got lots of
gray hair.&nbsp; Some people read my stuff because they want to benefit from the
lessons I learned from all the stupid mistakes I made which caused that gray
hair.</p>

<p>Which reminds me -- let me tell you a story...</p>

<h2>In hindsight, releasing on Halloween probably wasn't such a good idea.</h2>

<p>Last week was a <i>terrible</i> week at SourceGear.&nbsp; Most
weeks I really enjoy my job.&nbsp; By the end of last week, I was reminding myself
every hour that I get <i>paid</i> to do this.&nbsp; </p>

<p>Everything started out great on Monday, October 31<sup>st</sup>.&nbsp;
It was the very first day in our new office space, and our whole company had a
feeling of enthusiasm.&nbsp; We planned to release the Vault 3.1.3 maintenance
release that day.&nbsp; It was ready the week before, but it didn't make sense to
release it just before the move.</p>

<p>(Here at SourceGear, we ship a "maintenance release" of
Vault whenever we want to provide our customers with bug fixes or other minor
improvement.&nbsp; Our version numbering scheme is "Major.Minor.Maintenance".&nbsp;
Version 4.0.7 would indicate that it is the seventh maintenance release since
Vault 4.0.&nbsp; Historically, we have done one maintenance release each month or
so.)</p>

<p>It started raining around noon.&nbsp; Those of us with children
began to dread the prospect of going out to Trick-or-Treat in the rain.&nbsp; Still,
a little bad weather wasn't enough to squash the mood.&nbsp; Our new office space is
great, and we had a general feeling of confidence about 3.1.3.&nbsp; Vault 3.1 has
been a really solid product.&nbsp; The 3.1.3 release contained several bug fixes,
but none of them were really urgent.&nbsp; We shipped the release believing that it
would be the last maintenance release for quite a while.</p>

<p>Unfortunately, things didn't work out that way at all.&nbsp; The
3.1.3 release introduced two new bugs.</p>

<p>But we didn't know that yet when we came in Tuesday morning wearing
all smiles.&nbsp; The rain was gone and it was a beautiful fall day.&nbsp; Looking out my
east window I could see the bright sun highlighting the colors of the autumn
leaves on thousands of trees on the University of Illinois campus.&nbsp; With the
relocation and the 3.1.3 release behind us, I looked forward to having the
entire team focused on the development of Vault 4.0.</p>

<p>Then the groaning began.&nbsp; We found the first bug that
morning:&nbsp; Something in 3.1.3 broke the ability for the client to store certain
settings in the registry.&nbsp; It was a minor bug, but very annoying.&nbsp; Any user who
changed their personal settings after installing 3.1.3 was going to lose those
settings when we eventually released a fix.</p>

<p>The fix for this bug was easy.&nbsp; We really wanted to get it done
quickly.&nbsp; The longer we left 3.1.3 out there, the worse it was going to be.&nbsp; So
on Wednesday, we released version 3.1.4, containing nothing more than a fix for
this client settings bug.&nbsp; </p>

<p>I'm a golfer, so I refer to this kind of situation as a
"mulligan".&nbsp; In golf, a mulligan is basically a "do-over".&nbsp; You hit a bad shot,
so you just ignore it and try again.</p>

<p>I hate mulligans.&nbsp; We shipped a maintenance release 48 hours
after the previous one!&nbsp; This was just embarrassing, but we figured the best we
could do was just forget about it and go back to work.</p>

<p>When we came to the office Thursday morning, the world didn't
seem quite as wonderful as it did on Tuesday, but we were ready to be
optimistic again.&nbsp; The mulligan was behind us.&nbsp; We told ourselves we wouldn't
need another maintenance release for the rest of the year.&nbsp; Everyone went back
to being busy developing the cool new features for Vault 4.0.&nbsp; </p>

<p>And then we discovered the second bug which was introduced
in 3.1.3.&nbsp; The first bug caused groaning.&nbsp; This one provoked a few <a
href="http://www.imdb.com/title/tt0092007/quotes">colorful metaphors</a>.&nbsp; Here's
the bug:&nbsp; Add a binary file to the repository.&nbsp; Branch the folder containing
that file.&nbsp; Now try and retrieve that file from the branch.&nbsp; You can't.&nbsp; The
Vault server returns an error.</p>

<p>This bug had to be fixed.&nbsp; There was no other alternative.&nbsp; Developers
get kind of fussy when they can't get their files from the repository.&nbsp; </p>

<p>So on Friday we released Vault 3.1.5, the third maintenance
release in a week.&nbsp; This felt like one of the lowest points in our company
history.&nbsp; We started asking ourselves what went wrong.</p>

<h2>Regression Testing</h2>

<p>Clearly, this was a failure of "regression testing".&nbsp; I am a
little hesitant use this term, as it makes me sound like a testing guru when I
am not.&nbsp; The <a href="http://www.testing.com/cgi-bin/blog">real experts</a> in
the field of software testing can speak at great length about the many
different kinds of testing. &nbsp;There is unit testing, regression testing,
integration testing, system testing, black box testing, white box testing,
stress testing and that funky "Australian rules" testing where you have to hit
the bug with your fist.&nbsp; These guys can pick any one of these types of testing
and write an entire textbook on it. </p>

<p>Sometimes when I see all this jargon I break out in a Forrest
Gump imitation:</p>

<p style='margin-left:.5in'>"I'm not a smart man, but I know
what testing is." (<a href="/articles/gump.mp3">mp3</a>)</p>

<p>I am definitely not a testing guru, but I know about
regression testing.&nbsp; Regression testing is used to verify that you didn't
accidentally break something.&nbsp; Regression testing is what you do to make sure
that the product didn't accidentally get worse.&nbsp; Regression testing is the
testing you do to prevent mulligans.</p>

<p>Despite the fiasco here at SourceGear last week, we do
believe in regression testing.&nbsp; In fact, we use three different ways of
verifying that our product isn't moving backwards:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li ><b>Automated tests</b>.&nbsp; Our automated build system sends
     every Vault build through a suite of regression tests to verify that
     nothing got broken.</li>
 <li ><b>Manual tests</b>.&nbsp; Every build we release is manually
     examined by testers to verify that nothing looks broken.</li>
 <li ><b>Dogfooding</b>.&nbsp; We use our own product, so most of the
     time we catch problems before the bits ever leave the building.</li>
</ol>

<p>Somehow, those two bugs slipped through all three of these
safety nets.&nbsp; Evidently we need some more work in the area of regression
testing.</p>

<ul style='margin-top:0in' type=disc>
 <li >As luck would have it, we were already in the process of revamping
     our build system to use <a
     href="http://www.martinfowler.com/articles/continuousIntegration.html">continuous
     integration</a>.&nbsp; We originally started doing this because our customers
     want us to make sure that Vault works extremely well with <a
     href="http://ccnet.thoughtworks.com/">CruiseControl.NET</a>.&nbsp; But we will
     obviously gain the benefits internally as well.&nbsp; The concept makes
     enormous sense.&nbsp; If the product should "regress", we want to know as
     quickly as possible.</li>
 <li >So now we have a brand new automated build server which
     throws a hissy fit whenever something gets screwed up.&nbsp; It's an absurdly
     fast machine with dual-core Opterons and RAID disks.&nbsp; Our build/test time
     went from 45 minutes on the old machine to just 15 minutes now.&nbsp; We're
     also going to get one of those <a
     href="http://www.ambientdevices.com/cat/orb/orborder.html">nifty build
     orbs</a> that changes color whenever the build fails.</li>
 <li >Our next step is to write a few more regression tests to
     specifically deal with the situation from last week.</li>
 <li >Then we need to set up <a href="http://www.ncover.org/">NCover</a>.&nbsp;
     This will of course be a bad day.&nbsp; Code coverage is the perfect example of
     the old maxim that "things get worse before they get better".&nbsp; Everyone's
     experience with code coverage is basically the same.&nbsp; The first time you run
     code coverage, you are horrified because no matter how comprehensive you
     think your test suite is, the initial percent coverage is surprisingly
     low.&nbsp; That's the beauty of using code coverage -- it gives you a useful quantitative
     result to replace a qualitative guess which is almost always wildly
     optimistic.</li>
 <li >Finally, we need to start writing more regression tests
     and watch our percent coverage go up.</li>
</ul>

<p>Our build and test practices were already very important to
us.&nbsp; Now we're taking those practices to the next level.&nbsp; </p>

<p>However, and getting back to the place where this article
started, sometimes the way to prevent mulligans is to not break the code in the
first place.</p>

<h2>An ounce of prevention...</h2>

<p>So why would an ISV ever intentionally release a product
with known bugs?&nbsp; Several reasons:</p>

<ul style='margin-top:0in' type=disc>
 <li >You release with known bugs because you care about quality
     so deeply that you know how to decide which bugs are acceptable and which
     ones are not.</li>
 <li >You release with known bugs because it is better to ship a
     product with a quality level that is known than to ship a product which is
     full of surprises waiting to happen.</li>
 <li >You release with bugs because the alternative is to fix
     them and risk introducing more bugs which are worse than the ones you have
     now.</li>
</ul>

<p>All of the reasons for such a decision are tied up in this
one basic truth:</p>

<p style='margin-left:.5in'><span style='font-size:14.0pt'>Every
time you fix a bug, you risk introducing another one.</span></p>

<p>Every code change carries the potential for unintended side
effects.&nbsp; Stuff happens. </p>

<p>Even as I write this, I miss the blissful ignorance of life
in group 2.&nbsp; Don't we all start out with the belief that software only gets
better as we work on it?&nbsp; The fact that we need regression testing is somehow
like evidence that there is something wrong with the world.&nbsp; After all, it's
not like anybody on our team is intentionally creating new bugs.&nbsp; We're just trying
to make sure our product gets better every day, and yet, somewhere between
3.1.2 and 3.1.3, we made it worse.</p>

<p>But that's just the way it is.&nbsp; Every code change is a
risk.&nbsp; A development cycle that doesn't recognize this will churn indefinitely
and never create a shippable product.&nbsp; At some point, if the product is ever
going to converge toward a release, you have to start deciding which bugs
aren't going to get fixed.</p>

<p>To put it another way, think about what you want to say to
yourself when look in the mirror just after your product is released.&nbsp; The
people in group 2 want to look in the mirror and say this:</p>

<p style='margin-left:.5in'>"Our bug database has ZERO open
items.&nbsp; We didn't defer a single bug.&nbsp; We fixed them <i>all</i>.&nbsp; After every
bug fix, we regression tested the entire product, with 100% code coverage.&nbsp; Our
product is perfect, absolutely flawless and above any criticism whatsoever."</p>

<p>The group 1 person wants to look in the mirror and say this:</p>

<p style='margin-left:.5in'>"Our bug database has lots of open
items.&nbsp; We have carefully reviewed every one of them and consider each one to
be acceptable.&nbsp; In other words, most of them should probably not even be called
bugs.&nbsp; We are not ashamed of this list of open items.&nbsp; On the contrary, we draw
confidence from this list because we are shipping a product with a quality level
that is well known.&nbsp; There will be no surprises and no mulligans.&nbsp; We admit
that our product would be even better if all of these items were "fixed", but
fixing them would risk introducing new bugs.&nbsp; We would essentially be
exchanging these bugs which we find acceptable for the possibility of newly
introduced bugs which might be showstoppers."</p>

<p>I'm not talking about shipping crappy products.&nbsp; I'm not suggesting
that anybody ship products of low quality.&nbsp; I'm suggesting that decisions about
software quality can be tough and subtle, and we need to be really smart about
how to make those decisions.&nbsp; Sometimes a "bug" should not be fixed.</p>

<h2>Should we fix this bug or not?</h2>

<p>There are four questions to ask yourself about every bug:</p>

<p>&nbsp;</p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td valign=top style='border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>Question One</p>
  </td>
  <td valign=top style='border:solid windowtext 1.0pt;border-left:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p>When this bug happens, how bad is the impact?</p>
  </td>
  <td valign=top style='border:solid windowtext 1.0pt;border-left:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p>Severity</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:solid windowtext 1.0pt;border-top:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p>Question Two</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>How often does this bug happen?</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>Frequency</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:solid windowtext 1.0pt;border-top:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p>Question Three</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>How much effort would be required to fix this bug?</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>Cost</p>
  </td>
 </tr>
 <tr>
  <td valign=top style='border:solid windowtext 1.0pt;border-top:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p>Question Four</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>What is the risk of fixing this bug?</p>
  </td>
  <td valign=top style='border-top:none;border-left:none;border-bottom:solid windowtext 1.0pt;
  border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p>Risk</p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<p>Two of them are "customer questions", and the other two are
"developer questions".</p>

<h3>The Customer Questions:&nbsp; Severity and Frequency</h3>

<p>For the first two questions, I like to visualize Severity
and Frequency plotted on a 2D graph:</p>

<ul style='margin-top:0in' type=disc>
 <li >The vertical axis is Severity.&nbsp; </li>
 <ul style='margin-top:0in' type=circle>
  <li >The top of the graph represents a bug with extremely
      severe impact:<br>
      <i>"This bug causes the user's computer to burst into flame."</i>&nbsp; </li>
  <li >The bottom of the graph represents a bug with extremely
      low impact:<br>
      <i>"One of the pixels on the splash screen is the wrong shade of gray."</i>&nbsp;
      </li>
 </ul>
 <li >The horizontal axis is Frequency.&nbsp; </li>
 <ul style='margin-top:0in' type=circle>
  <li >The right side represents a bug which happens extremely
      often:<br>
      <i>"Every user sees this bug every day."</i>&nbsp; </li>
  <li >The left side represents a bug which happens extremely
      seldom:<br>
      <i>"This bug only affects people who live in eastern Washington state and
      who have both Visual Studio 2003 and Visual Studio 2005 installed and it
      only happens during leap years on the day that daylight savings time goes
      into effect and only if the first day of that month was a Tuesday."</i></li>
 </ul>
</ul>

<p align=center style='text-align:center'><img border=0
width=400 height=400 src="/scm/1564_image001.jpg"></p>

<p>Try not to get hung up figuring out the exact line or curve
which separates the bugs to be fixed from the bugs to be deferred.&nbsp; Speaking
very broadly, stuff gets more important as you move up or to the right of the
graph.&nbsp; The orange bug in the upper right should be fixed.&nbsp; The blue bug in the
lower left should not.&nbsp; </p>

<p>This graph isn't terribly useful as a formal analysis tool
for bug sorting.&nbsp; Attempts to be more quantitative are not likely to be
productive.&nbsp; However, the graph <i>can</i> be helpful as a communication tool.&nbsp;
Sometimes in a team discussion I actually draw this graph on a whiteboard when
I am trying to argue for or against a certain bug.</p>

<h3>The Developer Questions:&nbsp; Cost and Risk</h3>

<p>Questions One and Two are about the importance of fixing a
bug.&nbsp; Questions Three and Four are about the tradeoffs involved in fixing it.&nbsp; </p>

<p>Corollary: &nbsp;The answers to Questions Three and Four can only
make the priority of a bug go down, never up.&nbsp; If after answering Questions One
and Two it seems obvious that a given bug does not deserve attention, the other
two questions should be skipped.&nbsp; A common mistake is in using Question Three
to justify fixing a bug which isn't important.&nbsp; Don't make unimportant code
changes just because they're easy.</p>

<p>The real purpose of these two questions is when you already
know that the Severity and Frequency suggest that a given bug should be fixed.&nbsp;
The questions about Cost and Risk are like a dialog box that says, "Are you
sure?"</p>

<p>Every code change has a cost and a risk.&nbsp; Bad decisions
happen when people make code changes ignoring these two issues.</p>

<h2>Example:&nbsp; Item 6740</h2>

<p>Vault stores all data using Microsoft SQL Server.&nbsp; Some
people don't like this.&nbsp; We've been asked to port the back end to Oracle, PostgreSQL,
MySQL and Firebird.&nbsp; This issue is in our bug database as item 6740.&nbsp; The four
questions would look like this:</p>

<ul style='margin-top:0in' type=disc>
 <li ><b>Severity</b>:&nbsp; People who refuse to use SQL Server
     can't use Vault at all.</li>
 <li ><b>Frequency</b>:&nbsp; This "bug" affects none of our current
     users.&nbsp; It merely prevents a group of people (those who refuse to use SQL
     Server) from using our product.</li>
 <li ><b>Cost</b>:&nbsp; Very high.&nbsp; Vault's back end makes extensive
     use of features which are extremely specific to Microsoft SQL Server.&nbsp;
     Contrary to popular belief, SQL isn't portable.&nbsp; Adapting the backend for
     any other database would take months, and the ongoing maintenance costs of
     two backends would be quite high.</li>
 <li ><b>Risk</b>:&nbsp; In terms of newly introduced bugs, the
     primary risk here lies in any code changes we would make to the server to
     enable it to speak to different back end implementations of the underlying
     SQL store.</li>
</ul>

<p>Bottom line:&nbsp; This example is easy.&nbsp; It's obviously more of
a feature request than a bug.&nbsp; Still we've talked about this, and the four
questions play a part of the discussion.</p>

<h2>Example: Item 10016</h2>

<p>I told the story of Vault 3.1.3-4-5 mostly to illustrate the
fact that code changes can have unintended side effects and that we need more
regression testing.&nbsp; However, it is reasonable to discuss this fiasco in the
context of my four questions.</p>

<p>As an example, consider the "can't fetch binary files after
a branch" bug.&nbsp; We introduced this bug during an attempt to fix bug 10016, another
bug which involves a problem with conversion of End-Of-Line terminators for
Linux and MacOS users.&nbsp; The four questions for this EOL bug would have looked
something like this:</p>

<ul style='margin-top:0in' type=disc>
 <li ><b>Severity</b>:&nbsp; For a certain class of users, this bug
     is a showstopper for their use of Vault.&nbsp; It does not threaten data
     integrity, but it makes Vault unusable.</li>
 <li ><b>Frequency</b>:&nbsp; This bug only affects users on
     non-Windows platforms, currently a rather small percentage of our user
     base.</li>
 <li ><b>Cost</b>:&nbsp; The code change for this bug is small and
     appears simple.</li>
 <li ><b>Risk</b>:&nbsp; We obviously thought the risk here was low.&nbsp;
     Hindsight is 20/20.&nbsp; <b>:-)</b></li>
</ul>

<p>If regression testing had told us that the Risk was higher
than we thought, we would have revisited the four questions.&nbsp; Because the
Frequency is relatively low, we might have decided to defer this bug fix until we
figured out how to do it without breaking things.&nbsp; </p>

<p>In fact, that's what we ended up doing.&nbsp; In the 3.1.5
release last Friday, we simply un-did the fix for bug 10016.&nbsp; Bug 10016 is now
"open" again.&nbsp; A 3.1.6 maintenance release is therefore probably on the way.&nbsp; <b>:-(</b></p>

<h2>Example:&nbsp; Item 4860</h2>

<p>From an idealist's point of view, a nice feature of a
version control system is the fact that <a
href="/scm/scm_repositories.html">nothing ever really gets
deleted</a>.&nbsp; Your repository is a complete archive of every checkin which has
ever occurred.&nbsp; </p>

<p>But in real life, sometimes you actually do want to pretend
that something never happened.&nbsp; For these situations, Vault has a feature
called Obliterate.&nbsp; Unlike the Delete command, which doesn't really delete
anything, the Obliterate command is destructive.</p>

<p>Bug 4860 basically says that our Obliterate command is slow.</p>

<ul style='margin-top:0in' type=disc>
 <li ><b>Severity</b>:&nbsp; Obliterate is slow.&nbsp; Really slow.</li>
 <li ><b>Frequency</b>:&nbsp; Obliterate is not a command which is
     used every day.&nbsp; Still, most users need it once in a while.</li>
 <li ><b>Cost</b>:&nbsp; The effort required is very close to a
     complete rewrite of the feature.&nbsp; Ballpark estimate:&nbsp; One developer, code
     complete in a month.</li>
 <li ><b>Risk</b>:&nbsp; Stunningly high.&nbsp; This is the only feature
     in our product which destroys anything.&nbsp; Every other aspect of Vault was
     designed with a pathological paranoia over loss of data.&nbsp; </li>
</ul>

<p>Bug 4860 is a real pain the neck.&nbsp; Users gripe about it, and
we totally understand why.&nbsp; However, in terms of Severity and Frequency, we're only
talking about slow performance of a feature which is not frequently used.&nbsp; When
you add Risk to the discussion, it suddenly becomes easy for our developers to
procrastinate on bug 4860 and find something else more urgent to do.&nbsp; The
current implementation of this feature is slow as molasses, but it is known to
be safe.&nbsp; We are terrified of touching it.</p>

<p>Nonetheless, this bug is on the schedule for Vault 4.0.&nbsp; A
product in its 4.0 release should be more polished and refined than it was at
2.0.&nbsp; I am not fond of this feature, but I admit that bug 4860 is valid and its
time has come.</p>

<h2>Market Context</h2>

<p>Some of you already think I am making this issue far too
complicated.&nbsp; If so, you're not gonna like this next part.</p>

<p>Not only do you have to answer the four questions, but you
have to answer those questions with a good understanding of the context in
which you are doing business.&nbsp; Markets vary.&nbsp; Each has its own competitive
pressures and quality expectations.&nbsp; You need to understand two things:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li >Understand the Quality Expectations of your market
     segment.</li>
 <li >Understand what the Market Window is for your product.</li>
</ol>

<p>I'm probably going to get flamed for saying this, but it's
the truth, so here it is:&nbsp; The reason we can ship products with "bugs" is that
there are "bugs" that customers will find acceptable.&nbsp; Nobody wants a crappy
product, but that doesn't mean that everybody expects every product to be
utterly perfect.</p>

<h3>Quality Expectations</h3>

<p>Different market segments have different expectations about
product quality.&nbsp; People who write code for the space shuttle are dealing with
higher quality standards than people who write casual games.</p>

<p>Years ago I worked as part of a team where the quality
standards were incredibly high. &nbsp;We were building software which was burned
into the ROM of consumer cell phones.&nbsp; This is a world where mulligans are not
an option.&nbsp; You only get one chance to burn that ROM.&nbsp; Life is unbelievably bad
if you discover a serious bug just after your software shipped inside a million
phones.&nbsp; Our development cycles were incredibly long, since most of the time
was spent testing and bug-fixing until the code coverage level was well over
90% and the traceability matrix was complete.</p>

<p>At SourceGear we build and sell version control tools.&nbsp;
People use our product to store and manage their own source code.&nbsp; The quality
expectations in our market are extremely high, but there is still a gap between
those expectations and perfection.&nbsp; Understanding those expectations is an
important part of our decision-making.&nbsp; A bug which affects the safety of our
customers' data is obviously going to be prioritized higher than anything else.</p>

<p>The fact is that last week's mistakes are not going to be
fatal for SourceGear.&nbsp; In fact, in a bit of irony, it was our highest revenue
week ever.&nbsp; <b>:-)</b>&nbsp; </p>

<p>What happened last week was embarrassing and frustrating,
but the company will certainly survive.&nbsp; The bugs we introduced in 3.1.3 were a
potential inconvenience for our customers, but their data was never threatened,
and since they download Vault releases over the Internet, it's relatively
simple for us to release fixes.&nbsp; After three maintenance releases in five days,
we swallowed our pride, briefly acknowledged how happy we are that Vault is not
burned into the ROMs of a cell phone, and start figuring out how to prevent
mulligans in the future.</p>

<h3>Market Window</h3>

<p>We all know what happens if a product falls short of the customers'
quality expectations.&nbsp; For some ISVs, this is a problem, but most developers
naturally have a sense of craftsmanship and pride in their work.&nbsp; Good
developers want to exceed the quality standards of their customers.</p>

<p>But is it possible to make a mistake by going too far?&nbsp; Can
we err by exceeding the quality standards of our customers too much?&nbsp; Why would
anyone mind if we shipped a product which was higher quality than the market needs?</p>

<p>If quality could be obtained without tradeoffs, there would
be no problem.&nbsp; However, time is <i>always</i> a constraint.&nbsp; There is a "market
window" for your product, and it is closing.&nbsp; After a certain point, the market
doesn't want your product anymore.&nbsp; It's too late.</p>

<p>And product quality takes a <i>lot</i> of time.&nbsp; Increases
in the quality of your product tend to become an exercise in constantly
diminishing returns.&nbsp; Which of the following choices makes more sense?</p>

<ul style='margin-top:0in' type=disc>
 <li >Deliver a product today with a quality level that your
     market considers acceptable.</li>
 <li >Deliver a product one year later with a quality level that
     is higher than your market requires.</li>
</ul>

<p>Choosing the second option gives you the warm and fuzzy
feeling of building a really high quality product.&nbsp; This is a cool thing.&nbsp; Good
developers <i>must</i> have a sense of pride in their craftsmanship, and
nothing I say should be construed to diminish the importance of that.</p>

<p>Furthermore, having a higher quality product offers
competitive benefits.&nbsp; All else equal, fully informed customers will choose the
higher quality product.</p>

<p>But the fact is that shipping a year later means missing out
on a year of important benefits, not the least of which is revenue.&nbsp; In most
market segments, there is a competitor who is ready and willing to help
customers while you spend that year climbing the asymptotic hill toward product
perfection.&nbsp; Congratulations on building a product which makes you feel good.&nbsp;
Unfortunately, your ISV is now dead.</p>

<p>Remember, I'm not arguing for crappy software.&nbsp; I'm arguing
that building products to please yourself instead of your customers is always a
mistake.</p>

<p>Quality and craftsmanship are incredibly important.&nbsp; If you're
going to err to one side of this issue, obviously you should go for more
quality, not less.</p>

<p>But black-and-white perfectionist thinking will kill your
ISV.&nbsp; Most people can intuitively recognize that there is no such thing as a
software product which is absolutely 100% perfect.&nbsp; A central skill of managing
an ISV is making tough decisions about exactly<i> how </i>your product is going
to miss perfection.</p>

<h2>Eric, why are you making this so complicated?</h2>

<p>I'm not the one making this complicated -- it got that way all
by itself.&nbsp; <b>:-)</b></p>

<p>I know what you want.&nbsp; I want it too.&nbsp; I want a way to make all
these decisions easy.&nbsp; I want an algorithm with simple inputs that tells me
which bugs I should fix and the order in which I should fix them.</p>

<p>I want to implement this algorithm as a feature in our <a
href="http://www.sourcegear.com/dragnet/index.html">bug-tracking product</a>
and make gigabucks selling it to all those people who think they can save money
by hiring software development managers that are devoid of clue.&nbsp; Wouldn't this
be a killer feature?</p>

<ul style='margin-top:0in' type=disc>
 <li >In the Project Settings dialog, the user would enter a
     numeric value for "Market Quality Expectations" and a specific schedule
     for the closing of the "Market Window". </li>
 <li >For every bug, the user would enter numeric values for Severity,
     Frequency, Cost and Risk.</li>
 <li >The Priority field for each bug would then be
     automatically calculated.&nbsp; Sort the list on Priority descending and you
     see the order in which bugs should be fixed.&nbsp; The ones near the bottom
     will have a Priority less than zero, indicated that they should not be
     fixed at all.</li>
</ul>

<p>Heck, I'd probably even patent this algorithm.&nbsp; I have long
suspected that I am a complete hypocrite on the issue of software patents.&nbsp; In
principle, I believe that software patents are fundamentally evil, but my
ethics would probably do a 180 if I had a patent which allowed me to purchase a
Gulfstream jet.&nbsp; <b>:-)</b></p>

<p>Alas, this ethical quandary isn't going to happen, as "Eric's
Magic Bug Priority Algorithm" does not exist, and it never will.&nbsp; There is no
formula to make this easy.&nbsp; Figuring out exactly <i>how</i> your product is
going to be imperfect is hard.&nbsp; It <i>should</i> be hard.</p>

<p>The bad news is that there is no shortcut.&nbsp; Understand your
context, ask all four questions, and use your judgment.</p>

<p>The good news is that experienced developers can usually make
these decisions very quickly.&nbsp; In many cases, it only takes a few seconds to mentally
process the four questions and make a decision.&nbsp; In the tougher cases, gather
two coworkers near a whiteboard and the right answer will probably show up soon.&nbsp;
</p>

<h2>Eric Sink, Code Economist</h2>

<p>The title on my business card says "Software Craftsman", a
choice which reflects my preference for speaking of software development in
terms of craftsmanship rather than engineering or art.</p>

<p>But I admit that my metaphor is not a perfect match.&nbsp;
Comparing shrinkwrap software development to handcrafts doesn't adequately
reflect the part of my job which requires tough decisions.&nbsp; A cross-stitch
piece can be perfect.&nbsp; A non-trivial software product cannot. &nbsp;</p>

<p>For this reason, I also like to compare shrinkwrap software
development to macroeconomics.&nbsp; It's an optimization problem.&nbsp; Every choice
involves tradeoffs.&nbsp; Success is not found by building a perfect product, but
rather, by finding a perfect set of compromises.</p>

<p>Apparently Federal Reserve chairman Alan Greenspan is going
to be out of work in a couple months.&nbsp; Perhaps he should consider a career in
software?&nbsp; He might be good at it.&nbsp; <b>:-)</b></p>

<p></p>
