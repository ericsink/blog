---
layout: post
esbma_id: 1669
title: Requirements
date: 2007-05-14 12:47:17
keywords: (dev)
---
<p>Maybe it was that southern drawl.</p>

<p>Or maybe it was because I got mad.</p>

<p>I'm not sure <i>why</i> I still remember this moment so
clearly, but I do.&nbsp; It happened when I was at Spyglass, over ten years ago.&nbsp;
Several of us developers were in a meeting with Steve Stone, then
recently-hired as director of the Champaign office.&nbsp; We were talking about a
possible new feature.&nbsp; Steve, in his Alabama accent, asked, </p>

<p style='margin-left:.5in'>"So is that a <i>requirement</i>?"</p>

<p>A couple years later, I realized that I misunderstood the
question.&nbsp; I didn't have enough project management background to know the
particular way that he was using the word "requirement".&nbsp; For me at the time,
the word "requirement" had connotations of absolute necessity.&nbsp; So when Steve
asked the question, here is what I heard:</p>

<p style='margin-left:.5in'>"So is this feature something that
absolutely must be in the next release of the product?"</p>

<p>On top of that, I'll confess I was sort of generally crabby
at that point in my life, especially with respect to Steve Stone.&nbsp; Instead of
promoting me or one of the other lead developers to run the Champaign office,
Spyglass had hired Steve from the outside.&nbsp; In fact, Spyglass asked me to interview
Steve, but only <i>after</i> the interview did they tell me I had actually been
interviewing my new boss.</p>

<p>Anyway, I was in a generally foul mood when I misunderstood
this question.&nbsp; I suppose that's why I answered Steve by saying something like
this:</p>

<p style='margin-left:.5in'>"How the @%$* should I know if this
feature has to be in the product or not?&nbsp; You're new here, so let me explain
how things go.&nbsp; Management moved the headquarters to Chicago after years of
promising that they never would.&nbsp; Here in Champaign, nobody tells us anything.&nbsp;
We've got no marketing people except the team who spent 3 months deciding which
Pantone color is the right shade of red for our company logo, which nobody ever
sees because our product is an OEM component.&nbsp; The only way we ever know that a
feature absolutely must be in the product is when one of our Sales Guys calls
up and tells us that he already promised it."</p>

<p>Steve was a very patient man.&nbsp; I assume anybody who lived in
  Alabama would have to be.&nbsp; <b>:-)</b>&nbsp; He just smiled as he listened to my
rant (footnote 1).</p>

<p>But my career with Spyglass didn't last too much longer
after that.&nbsp; A few months later, in a moment when I was ready to throw another
tantrum, I decided to just quit instead.</p>

<p>And I went out on my own and founded SourceGear.&nbsp; We started
out doing contracting projects.&nbsp; One of our first clients asked me for a
Software Requirements Specification (SRS) and a Traceability Matrix.&nbsp; That wasn't
a very good day.</p>

<p>But not long after that, I learned what the word
"requirement" means when used in the context of software project management.</p>

<p>And I learned what Steve Stone had really meant when he
asked that infuriating question.&nbsp; When Steve said:</p>

<p style='text-indent:.5in'>"So is that a <i>requirement</i>?"</p>

<p>What he was really asking was:</p>

<p style='margin-left:.5in'>"So it sounds like we just
identified something that should become part of our spec.&nbsp; You guys have a spec
around here somewhere, right?&nbsp; Who is responsible for updating that spec to
capture this new item?"</p>

<h3>What is a Requirement?</h3>

<p>I define a requirement as "one piece of a spec".&nbsp; Is that
definition complete and immune to attack?&nbsp; No, but I think it's the simplest
definition that works.</p>

<p>Of course, it relies on the definition of a "spec", so let's
go there.</p>

<h3>What is a Spec?</h3>

<p>A spec is short for "specification".&nbsp; A spec is something
that describes what a piece of software should do.</p>

<p>For the moment I am being deliberately broad and inclusive.&nbsp;
If you are experienced in software project management, you probably have something
very specific in mind when think of the words "spec" or "requirement".&nbsp; In
fact, it is possible that you are not willing to acknowledge that something is
a spec unless it matches up fairly well with your image of same.&nbsp; That's okay.&nbsp;
Just stay with me.</p>

<p>For now, I'm saying that anything that is a "description of
what a piece of software should do" can be considered a spec.&nbsp; This may
include:</p>

<ul style='margin-top:0in' type=disc>
 <li >A document</li>
 <li >A bunch of 3x5 note cards</li>
 <li >A spreadsheet containing a list of features</li>
</ul>

<p>I am currently involved in a project where my role is "The
Walking Spec".&nbsp; In other words, I am the person who mostly knows everything
about how this piece of software should mostly behave.&nbsp; When people need a
spec, they ask me a question (footnote 2).&nbsp; I'm not saying that I am a good
spec, but I don't think I'm the worst spec I have ever seen, and I am certainly
better that no spec at all.&nbsp; <b>:-)</b></p>

<p>Seriously, a spec needs to be in a form which is accessible
to more than one person.&nbsp; It needs to be written down, either in a computer or
on paper.</p>

<p>But how?</p>

<h3>Document or Database?</h3>

<p>There is a constant tension over the form of a spec.&nbsp; Should
it be a document or a database?</p>

<p>I'm using the words "document" and "database" as names for
the two extremes which create this tension.&nbsp; </p>

<ul style='margin-top:0in' type=disc>
 <li >When a spec is more like a document, it looks like a bunch
     of paragraphs and prose and pictures.&nbsp; </li>
 <li >When a spec is more like a database, it looks like a bunch
     of bullets and lists and outlines.</li>
</ul>

<p>When a spec is being written, it wants to be a document.&nbsp;
It's easier to describe what a piece of software should do when we can use
paragraphs and prose and formatting.</p>

<p>Maybe this is because the primary content of a spec is
usually coming from someone other than a developer.&nbsp; We developers sometimes
write apps for ourselves, but that's not the common case.&nbsp; More often, we're
writing software that somebody else wants.&nbsp; We don't know how the software
should behave.&nbsp; They do.&nbsp; In order for the software to be born, they need to
express to us everything they know about what the software should do.&nbsp; That
expression is a spec.</p>

<p>And in all likelihood, that expression is more naturally
going to be like a document and less like a database.&nbsp; The person will want to
tell stories and give examples and rationale.&nbsp; They may want to include pictures
or video to explain.</p>

<p>But right after a spec is written, a document is usually the
wrong form.&nbsp; It started out as a document only because that form was most
convenient for the author.&nbsp; But a document is not the most convenient form for
the people who are reading or using the spec, and those people have the author
outnumbered. &nbsp;Most of those readers/users want that spec to be a database
instead of a document.</p>

<p>They want the spec to be logically broken up into a bunch of
little pieces.&nbsp; Each piece should be a self-contained statement about one
single detail of how the software should behave.</p>

<p>Breaking a spec into little pieces allows us to use that
spec more effectively.&nbsp; We can more easily divide the software construction
tasks across a team by assigning different pieces to different people.&nbsp; We can
then print the pieces as a list, put boxes to the left of each one and use it
as a checklist to make sure we're getting everything done.</p>

<p>So, let's return to the original question.&nbsp; What is a
"requirement"?</p>

<p>A requirement is a piece of a spec.&nbsp; When we take a spec and
put it into its more useful form by breaking it into bite-sized pieces, each of
those pieces is a requirement.</p>

<h3>Corollary</h3>

<p>If you are in the habit of ignoring specs, you can ignore
requirements in exactly the same way.&nbsp; They're no different.&nbsp; <b>:-)</b></p>

<h3>Writing Requirements</h3>

<p><i>"Dad, where do products come from?"</i></p>

<p><i>"Well, son, when a company and a market segment really
love each other, they..."</i></p>

<p>Every software product starts out as a gleam in the eye of some
guy who wants to make money.&nbsp; He sees a bunch of people who have money.&nbsp; He
pauses to reflect upon how much nicer life would be if that money were moved from
their wallets into his own.</p>

<p>So, he pursues a process which involves the following two
steps:</p>

<ol style='margin-top:0in' start=1 type=1>
 <li >Find an idea for a product</li>
 <li >Build that product</li>
</ol>

<p>Things usually fall apart between steps 1 and 2, mostly
because these two steps are done by different people.&nbsp; The product is not being
built by the same person who had the idea and the gleam.&nbsp; Step 1 is usually
somebody in marketing.&nbsp; Step 2 is a team of developers.</p>

<p>So, in order for the developers to know what product to
build and how, we need to describe it to them (via a spec) with lots of details
(requirements).</p>

<h3>Construction and Testing</h3>

<p>With a well-written requirements spec, the development of a
software project is easy.</p>

<p>Let's assume the project starts out with a spec that is:</p>

<ul style='margin-top:0in' type=disc>
 <li ><b>Complete</b>.&nbsp; The spec describes everything the
     product needs to do.&nbsp; Nothing was forgotten.</li>
 <li ><b>Stable</b>.&nbsp; The spec isn't in flux.&nbsp; It's not going to
     change along the way.</li>
 <li ><b>List-oriented</b>.&nbsp; The spec is like a database; each
     item being a self-contained requirement.&nbsp; All the prose has been
     appropriately broken up into little pieces.</li>
</ul>

<p>This is the dream scenario for a development manager.&nbsp;
Translate all the requirements into a set of tasks.&nbsp; Divide up all the tasks
between the developers on the team.&nbsp; How hard can that be?</p>

<p>Similarly, the testing lead has a very straightforward path
with this kind of a requirements spec.&nbsp; For every requirement, create one or
more tests that can be used to verify that the software meets that
requirement.&nbsp; Automate as many of those tests as possible.&nbsp; Every time the
developers create a new build, run the tests and report what happened.&nbsp; Easy,
right?</p>

<p>Unfortunately, projects don't always work that way.</p>

<p>In fact, projects almost never work that way, because most
requirements specs are badly written.</p>

<h3>Bad Requirements</h3>

<p>A bad requirements spec is considerably more likely than a
perfect one.&nbsp; Certain kinds of problems are common.</p>

<p>For example, let's suppose we are building a game which is
designed to be played by middle school girls in a library.&nbsp; The following
examples show some typical problems with requirements:</p>

<p style='margin-left:.5in'><b>Missing Requirements</b></p>

<p style='margin-left:.5in'>Very often, the spec simply isn't
complete.&nbsp; Somebody forgot to include an important detail.</p>

<p style='margin-left:.5in'>For example, since we know the game
is supposed to be played in libraries, users will need to turn the sound down
or off.&nbsp; So we need the game to be playable without sound.&nbsp; If we forget to
mention this requirement specifically, there's a decent chance the dev team
will create a game where sound is important to game play.</p>

<p style='margin-left:.5in'><b>Unclear Requirements</b></p>

<p style='margin-left:.5in'>Sometimes requirements are
ambiguous.&nbsp; Here's an unclear requirement:</p>

<li>The game must be compatible with DirectX.</li>

<p style='margin-left:.5in'>Which version?&nbsp; Can we use DirectX
10, thus requiring Windows Vista?&nbsp; Or should we target DirectX 9 and stay
compatible with Windows XP?&nbsp; It's not clear.</p>

<p style='margin-left:.5in'><b>Non-prioritized Requirements</b></p>

<p style='margin-left:.5in'>A good requirements spec contains
priority information to help the dev team make the right tradeoffs. &nbsp;If some
requirements are more important than others, the spec should say so.</p>

<p style='margin-left:.5in'>Consider these two requirements:</p>

<li>The user must be allowed to save a game in progress and resume it
later.</li>

<li>The main character in the game must resemble Dakota Fanning
without looking exactly like her.</li>

<p style='margin-left:.5in'>The schedule is getting tight.&nbsp;
Only one of these two features is going to make it.&nbsp; Do you want to leave this
choice entirely up to the dev team?&nbsp; Or do you want to make it clear that
save/load is a more important feature than making the main character resemble a
certain child actress? (footnote 3)</p>

<p style='margin-left:.5in'><b>Missing Anti-Requirements</b></p>

<p style='margin-left:.5in'>Sometimes the problem is that the
development team tries to go above and beyond the call of duty and sneak
something in that wasn't part of the spec.&nbsp; This can be a good thing, but it
can also be a bad thing.&nbsp; A good requirements spec will contain "anti-requirements",
explicitly spelling out things that should not be done.&nbsp; For example:</p>

<li>This game must not have a grenade launcher.</li>

<p style='margin-left:.5in'>Believe me, if you leave too much
latitude on a game project like this, we developers will turn it into a first
person shooter.&nbsp; Yes, we can see from the spec that the target customer is a 12
year old girl playing in a library.&nbsp; But still, our intuition is that all games
need a grenade launcher, so you're gonna get one if you don't explicitly tell
us otherwise.</p>

<h3>Changing Requirements</h3>

<p>If a project gets all the way to completion with bad
requirements, the likelihood is that the software will be disappointing.&nbsp; When
this happens, the resulting assignment-of-blame exercise can be fun to watch.&nbsp;
From a safe distance.</p>

<p>More often, during the project somebody notices a problem
with the requirements and changes them along the way.</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Marketing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By
the way, I forgot to mention that the application has to be compatible with
Windows 95.</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Development:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows
95?&nbsp; You're kidding, right?&nbsp; People stopped using Win95 over a decade ago!</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Marketing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Oh,
and Mac OS 7.6 too.</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Development:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?&nbsp;
We're building this app with .NET 3.0 and we're already 40% done!</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Marketing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You're
half done?&nbsp; That's great!&nbsp; Oh, and I forgot to mention we need compatibility
with the Atari ST.</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Development:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Why
didn't you tell us this before we started?</p>

<p style='margin-left:1.5in;text-indent:-1.25in'>Marketing:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sorry.&nbsp;
I forgot.&nbsp; It's no problem to change it now, right?</p>

<p>Changing requirements mid-project can be expensive and
painful.</p>

<p>However, it is very rare to have a project where all the
requirements are known and properly expressed before development begins.&nbsp; So,
it behooves us to prepare for changes.&nbsp; If we choose a development process which
rigidly requires a perfect spec before construction can begin, we are just
setting ourselves up for pain.&nbsp; We need to be a bit more agile.</p>

<h3>Agile</h3>

<p>I lament the loss of the word "agile".</p>

<p>A minute ago when I used the word "agile", most readers
immediately thought I was talking about <a
href="http://en.wikipedia.org/wiki/Agile_software_development">Agile software
development</a> practices such as Scrum or Extreme Programming.&nbsp; That means
your reaction was probably polarized toward one of the following two extremes:</p>

<ul style='margin-top:0in' type=disc>
 <li >Oh, great!&nbsp; I'm five pages into this article and suddenly
     I find out Eric Sink is one of those Extreme Programming fanatics?&nbsp; I
     guess that's 15 minutes of my life I'll never get back.&nbsp; Sorry, I don't
     mind visiting once in a while like on Christmas or Easter, but I'm just
     not interested in having somebody tell me how to live my life.&nbsp; And I
     don't want some Agile priest telling me that I'm not a true believer just
     because we don't do pair programming.</li>
 <li >Oh, great!&nbsp; Here's Eric Sink trying to pretend like he's a
     believer when everybody knows he's not.&nbsp; Actually I guess I should check
     the Central Membership Roll just to be sure.&nbsp; Nope, I was right.&nbsp; He's
     not.&nbsp; Even if he was, we would have to excommunicate him anyway.&nbsp; Anybody
     who reads the drivel on his blog knows darn well that his doctrine is
     seriously screwed up.</li>
</ul>

<p>I just want to use the word "agile" without all those
connotations.&nbsp; My copy of Merriam Webster's Tenth Edition says that "agile"
means "marked by ready ability to move with quick easy grace".&nbsp; At a high
level, that's all I'm trying to say.&nbsp; Sometimes requirements change.&nbsp; Be ready.</p>

<p>In more practical terms, I'll admit that the body of wisdom
literature produced by the Agile movement has some very good stuff in it.&nbsp; But
Agile is no different from any other major religion like Christianity or
Buddhism.&nbsp; You can learn some great principles and practices there, but
formally becoming a member is a decision that should not be made lightly.</p>

<p><b>:-)</b></p>

<h3>Traceability</h3>

<p>I've tried to write this article at a fairly high level,
focusing more on principles than practices, staying inclusive of the broad
range of viable methods for getting projects done.&nbsp; However, the truth is that
the word "requirement" is usually associated with stricter and more formal ways
of doing things.</p>

<p>We developers say that we don't like formality and
strictness, but I think we're confused.</p>

<p>We don't like being told what to do.&nbsp; We don't like stupid
rules that don't make sense.&nbsp; We don't like working for some stupid
pointy-haired-boss who draws arbitrary boundaries that we're not allowed to
cross.</p>

<p>But we spend our entire day using a compiler, and compilers
are very formal and strict.&nbsp; In C, if we type <span style='font-family:"Courier New"'>primtf</span>
instead of <span style='font-family:"Courier New"'>printf</span>, the compiler
will let us go no further until we stop and fix it.&nbsp; In C#, if we try to use an
uninitialized local variable, our compiler will scold us for stepping outside
the boundaries.</p>

<p>Do we go out after work and gripe about our compiler?</p>

<p style='margin-left:.5in'>"I am sick and tired of that stupid
compiler!&nbsp; When I do something right it never says a word, but if I do the
slightest little thing wrong, it throws a fit. &nbsp;Why does it have to nitpick
about every little mistake I make?"</p>

<p>Nope.&nbsp; Actually, we like compilers.&nbsp; We like the formality
and strictness.&nbsp; We know having a compiler to catch our mistakes is a good
thing because it allows us to go faster.&nbsp; It's safe to sit down and crank out a
thousand lines of code as fast as we can because we know the compiler will find
a lot of the little errors that happen.</p>

<p>Wouldn't it be great if every phase of the software
development process had a compiler?</p>

<ul style='margin-top:0in' type=disc>
 <li >I want a piece of software that tells me if I forget to
     implement one of the requirements.</li>
 <li >When my requirements conflict with each other, my "spec
     compiler" should output an error.</li>
 <li >When one of my requirements isn't being verified by
     anything in the test suite, some piece of software should tell me.</li>
</ul>

<p>The compiler I want doesn't exist today, but there are
things we can do to approximate that style of work.&nbsp; For example, <a
href="/articles/Code_Coverage.html">code coverage</a> can be
used to help verify that things are getting tested.&nbsp; Automated testing can help
catch bugs that slip in.</p>

<p>The concept which may eventually get us the compiler I want
is called "traceability".&nbsp; The idea is that everything should be traceable back
to something else.</p>

<ul style='margin-top:0in' type=disc>
 <li >Every piece of code in the project should exist because it
     helps meet one or more requirements.&nbsp; Traceability should allow us to ask,
     "Which requirement motivates this piece of code?"&nbsp; If the answer is
     "none", then that piece of code should be excised.</li>
 <li >Every requirement needs to be tested.&nbsp; Traceability should
     allow us to ask, "Which tests verify that this requirement is being met?"&nbsp;
     If the answer is "none", then we need to write some more tests.</li>
</ul>

<p>Lacking my super-duper application lifecycle compiler that
verifies that everything is traceable, we can keep track of some of this stuff
using a <a href="http://en.wikipedia.org/wiki/Traceability_matrix">traceability
matrix</a>.</p>

<p>When it functions more like a compiler than a pointy-haired-boss,
a little extra formality and strictness can be very helpful.</p>

<h3>Requirements Management Software</h3>

<p>Naturally, we want to use software to manage our
requirements.&nbsp; Many folks do this with a general-purpose tool like a word
processor or a spreadsheet.&nbsp; That works fine.</p>

<p>Some people track requirements in a bug-tracking system.&nbsp;
This can work, but it's not a perfect solution.&nbsp; Requirements and bugs are
different.&nbsp; For example, requirements don't change status from Open to Closed
to Verified.</p>

<p>Another approach is to use something which is specifically
designed to track requirements.&nbsp; Application Lifecycle Management (ALM)
software often contains features for managing and tracking requirements.&nbsp; The
ALM solutions from companies like IBM Rational, Serena and Borland are
examples, but it should be noted that these solutions are very expensive and
designed for large enterprise environments.</p>

<p>My own company will soon be releasing an ALM solution which
is designed specifically for smaller teams.&nbsp; We call it SourceGear Fortress.&nbsp;
However, the 1.0 release will not have any features specifically designed for
tracking requirements.&nbsp; We do intend to include this and other features in the
future as we evolve Fortress into a mature and complete ALM solution.</p>

<p>Microsoft made a similar choice with Visual Studio Team
System.&nbsp; However, since their product is enterprise-focused, it has been
criticized for not having any requirements features in the first release
(footnote 4).&nbsp; I suspect that this is a hole they plan to plug at some point in
the future.</p>

<h3>Additional Reading</h3>

<p>This short article barely scratches the surface of a very
complex topic.&nbsp; For additional information, I recommend the book <a
href="http://www.amazon.com/exec/obidos/ASIN/0735618798/sawdust08-20">Software
Requirements</a> by Karl E. Wiegers.</p>

<h3>Footnotes</h3>

<p style='margin-left:.5in;text-indent:-.5in'><span
style='font-size:10.0pt'>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I have no hard feelings toward my old
boss at Spyglass.&nbsp; I lost touch with Steve Stone, but I understand he later
left the company and joined Microsoft.&nbsp; A little searching with Google reveals
that he is currently the CEO of a startup company called <a
href="http://infoflows.com/">InfoFlows</a>.&nbsp; Steve, if you are reading this
article, best regards.</span></p>

<p style='margin-left:.5in;text-indent:-.5in'><span
style='font-size:10.0pt'>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rest assured that this project is <i>not</i>
one of SourceGear's products.&nbsp; It's a revision to one of our internal systems.</span></p>

<p style='margin-left:.5in;text-indent:-.5in'><span
style='font-size:10.0pt'>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hypothetically, the reason this save
feature might be so important is to ensure that when the hypothetical father of
the hypothetical middle school girl arrives at the hypothetical library to pick
her up, she can save her game and go promptly so her Dad doesn't have to wait.&nbsp;
Hypothetically.</span></p>

<p style='margin-left:.5in;text-indent:-.5in'><span
style='font-size:10.0pt'>&nbsp;(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Third-party products are available to
add requirements management features to VSTS.</span></p>

<p></p>
