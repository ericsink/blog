---
layout: post
esbma_id: unknown
title: Why your F# evangelism isn't working
date: 2015-01-05 12:00:00
keywords: (fsharp)
---

<h2>Ouch. Eric, you're one of those anti-F# people, aren't you?</h2>

<p>Nope.</p>

<p>If you skim this blog entry too quickly or just read the title, you might 
think I am someone
who does not like F#.  Nothing could be further from the truth.
Over the last several months, I have become a big F# fan.
It has become my preferred language for personal projects.</p>

<p>My <a href="https://github.com/ericsink/LSM">current side project</a> is a 
key-value store in F#.  I have learned a lot by writing it, and I am
even starting to think it might end up becoming useful.  <tt><b>:-)</b></tt></p>

<p>Mostly, I find coding in F# to be extremely satisfying.</p>

<p>I am writing this article not as an opponent of F#, but rather,
as someone who hopes that F# will become a mainstream .NET language.</p>

<h2>Eric, you're wrong.  F# is mainstream already.</h2>

<p>Of course it is.  For some definition of "mainstream".</p>

<p>F# is gaining traction really fast.  People are using F# for
real stuff.  The language is improving.  Xamarin is supporting it.
By nearly any measure, F# is showing a lot of momentum 
over the last few years.  If you are an F# fan, there just isn't
any bad news running around.</p>

<p>But for this article, I am using a definition of "mainstream",
(which I'll explain below) which I believe F# has not yet reached.</p> 

<p>If, when you arrive at the end of this article, you
do not like my definition of mainstream, that's okay.
Just take a copy of this article, and
do a search and replace all instances of the word
"mainstream" with "purple".
I have no desire to argue with you about what "mainstream"
means, but if you want to argue about the meaning of "purple",
I'll be happy to.  <tt><b>:-)</b></tt></p>

<h2>You're wrong again.  My F# evangelism IS working</h2>

<p>Of course it is.  To a certain extent.</p>

<p>But in marketing terminology, as far as I can tell, most F# users today are
"early adopters".  Very few are "pragmatists".  And F# has not yet "crossed
the chasm".</p>

<h2>What is "the chasm"?</h2>

<p>The term originates from a 1991 book by Geoffrey Moore.</p>

<p>The main point of Moore's book is that the classical
marketing bell curve has a problem.  Typically (and, prior
to Moore's book, always), that bell curve is drawn like this:</p>

<p><img src="/bell.gif"/></p>

<p>The basic idea of this curve is that when a market adopts a new techology,
it follows a pattern.  The technology moves from left to right
on the bell curve, becoming adopted by four groups in the following order:

<ul>
    <li><p>the "early adopters" (people who like trying
    new technologies) </p></li>
    <li><p>the "pragmatists" (people who only care about
    technology to get something done) </p></li>
    <li><p>the "conservatives" (pragmatists,
    but even more risk-averse) </p></li>
    <li><p>the "laggards" (people who actively
    avoid new things)</p></li>
</ul>

<p>Together, the pragmatists and conservatives are the definition
of "mainstream" for the purpose of this article.</p>

<p>Moore's key observation is that moving from the early adopters
to the pragmatists is very hard.  Some technologies never make
it.  To illustrate this problem, Moore suggests drawing the
bell curve differently, with a "chasm" between the early adopters
and the pragmatists:</p>

<p><img src="/bell2.gif"/></p>

<p>His book explains why the chasm exists, why some technologies
"die at the bottom of the chasm", and how some technologies
successfully "cross the chasm".  It is a marketing classic and
highly recommended.</p>

<p>For the purpose of this blog entry, the main thing you need
to know is this:  The chasm exists because pragmatists
generally adopt new techologies as a herd.  They don't adopt
a new technology until they see other pragmatists using it.
This creates a chicken-and-egg problem.</p>

<h2>How does this herd thing work?</h2>

<p>Pragmatists have an annual conference where they all agree
to stay with their existing technologies.  The actual vote is
not formal, but consensus gets reached.</p>

<p>A lot of this process happens in hallways and the dining hall:
"Are you considering
Windows 8 or should we all just stay with Windows 7 and
see what happens next?"</p>

<p>Some of the process happens in the conference itself,
where you'll see session titles like, "Why it's safe for
you to ignore mobile for another year."</p>

<p>At PragmatiCon 2014, the ratified platform looked something
like this:</p>

<ul>
    <li><p>SQL is still the only safe choice.</p></li>
    <li><p>Keep an eye on your developers to make sure they're not using Ruby.</p></li>
    <li><p>Exchange is still the best email solution.</p></li>
    <li><p>The cloud is okay for some things, but important data needs to stay in your own server room.</p></li>
    <li><p>Let's ignore BYOD and hope it goes away.</p></li>
    <li><p>Building a mobile app is still too expensive and too risky.</p></li>
</ul>

<h2>So the pragmatists don't care about the ways that F# is better?</h2>

<p>No, not really.</p>

<p>This point is where the title of this blog entry comes from.  If you
are trying to explain the benefits of F# to pragmatists, you are probably
frustrated.  It probably seems like they're not listening to you.  That's because they're not.</p>

<p>Pragmatists don't make technology decisions
on the basis of what is better.  They prefer the safety of the herd.
A pragmatist wants to be using the same technology as all the other
pragmatists, even if everybody is somewhat unhappy with it.  They
will choose "predictably disappointing" over "excellent and unproven"
every time.</p>

<h2>Maybe we just need to do a better job of explaining the benefits of F#?</h2>

<p>Wouldn't it be great if it were that simple?</p>

<p>But no.  As an early adopter, there is nothing you can say to a
pragmatist that will make a difference.  They know that your opinion
and experience are not to be trusted, because they do not share your
values.</p>

<h2>So these pragmatists are just stupid then?</h2>

<p>Not at all.  Their decision-making process is quite rational.  It
is a natural consequence of being someone who uses technology to get
something done rather than using technology for its own sake.</p>

<p>Near the top of this blog entry, I said that I find coding in F# to be extremely satisfying.
That remark identifies me as an early adopter.  It is something
a pragmatist would never say.  If any pragmatists accidentally stumbled
across this blog entry, they stopped reading right there.</p>

<p>Pragmatists don't care about the
craft of software.  They don't care about how cool something is.
They care about cars and investments and law
and soap and oil rigs and health care and construction and transportation and insurance.  
Technology is just a tool.</p>

<p>BTW, if you find the word "pragmatists" to be too tedious to pronounce,
you can just refer to these folks by their more commonly-used label: "normal people".</p>

<h2>Fine.  We don't need those pragmatists anyway, right?</h2>

<p>Maybe not.  Some things stay in the land of early adopters
forever.</p>

<p>But the area under the bell curve matters.  It is roughly
equivalent to revenue.  Together, the pragmatists and conservatives
represent almost all of the money in the market.</p>

<p>If your situation allows you to be successful with a given
technology even though it only gets used by early adopters,
great.  But many people are (directly or indirectly) placing
bets (financial or otherwise) which will only pay off when
their technology get used by the majority of the market.</p>

<h2>So this chicken-and-egg situation is hopeless then?</h2>

<p>Not quite.</p>

<p>Sometimes a pragmatist can be convinced to break with the herd.
The key is to find what Moore calls a "pragmatist in pain".</p>

<p>A pragmatist in pain is someone whose needs are not being well
met by whatever technology is current popular among pragmatists.
The current technology is not merely annoying them.  It is failing
them.</p>

<p>A pragmatist in pain actually does care about how F# is
better, even though this goes against their nature.
They really hate the idea of listening to some F# nerd
prattle on about immutability and type inference.  But
they have reached their last resort.  Their pain has forced them 
to look for hope from somebody outside
the herd.</p>

<p>This is how a new product gets across the chasm.  Find a pragmatist
in pain.  Do whatever-it-takes to make them happy with your
product.  Then go back and do it again.  Repeat until you have enough customers
that they can go to PragmatiCon without being shunned and ridiculed.</p>

<h2>Why will it be especially hard for F# to cross the chasm?</h2>

<p>Because C# is really, really good.</p>

<p>I love C#, but I hold the opinion that F# is better.</p>

<p style="margin-left:1in;">Kirk: "Better at what?"  <br/>Khan: "Everything."<br/><tt><b>:-)</b></tt></p>

<p>I also understand that F#'s awesomeness is basically
irrelevant to the question of whether it will go mainstream
or not.  If the pragmatists are not in pain, they are not
interested.  C# doesn't cause very much pain.</p>

<h2>Will the hybrid functional-first languages cross the chasm together?</h2>

<p>Mostly, no.</p>

<p>Certainly it is true that F# is part of a trend.  The Java world
has Scala.  The Apple/iOS world has Swift.  It is not merely true
that F# is gaining momentum.  It is also true that functional programming
is gaining momentum.</p>

<p>But in terms of going mainstream, these three languages will
be related-but-separate.  If Swift cross the chasm first (and it will),
that will add a bit more momentum to F#, simply because the two
languages will be seen as comparables in different ecosystems.  
But F# will have to cross the chasm on its own.</p>

<h2>Why will Swift go mainstream before F#?</h2>

<p>Yes, F# has a seven year head start, but Swift will cross the
chasm first.  This has nothing to do with the relative merits
of these two languages.</p>

<p>As of January 2015, F# is quite stable
and trustworthy for most use cases, while Swift is mostly an unstable
mess that isn't ready for prime time.  This too is irrelevant.</p>

<p>The simple fact is that C# is kinda great and Objective-C is
kinda dreadful.  Swift will go mainstream first because you can't
swing a 9-iron in the Apple/iOS ecosystem without hitting a
pragmatist in pain.</p>

<h2>Eric, you're wrong.  I know some pragmatists who are using F#.</h2>

<p>Really?  Great!  Please spread the word.</p>

<p>&nbsp;</p>

