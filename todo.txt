
front matter

take exact contents of s3 bucket

for every file, see if it is templated, and
if so, remove the template, leaving the actual
inner content in a .ehtml file

then g, for every file, if .ehtml, then apply
the the template, alpha and omega.  should match
the content retrieved from s3 bucket.

--

what to do about the print- items?

should be able to take the output of h, process
with the template, and the result should be
identical to blog_live

article title and date filed kinda move into the content

when gen with template from output of h, how to get
the title so we can put it in the HTML title element
in head?

--

starting point data dir is missing a bunch of
entries as a compared to the live site

responsive:  get rid of sidebar?  just a header
and footer?

consider not having ids?  store the content
in the same layout as the site.  directories
are not items.  use file suffix to denote whether
to crunch and/or use template.  everything else
is just copied.

.ehtml

does meta go inside there, or in a separate .emeta file?

link crunching doesn't seem that useful.  although
it does eliminate the problem of a link that goes
nowhere because of a typo.  but this could be
checked differently.

--

the toc entries converted from a script to static
are now using hard-coded links instead of
{{{link:id='n'}}}
which may not be a problem

maybe write script to convert all the entries
to markdown

investigate fornax

investigate md with layout, scss

update style and template

update copyright dates

where is vcbe content?

--

autogen dsl

viewmodels, but maybe not using the term
the way everyone else does.  all rx.

validators

layout completely separate layer

XF but mostly doesn't know, no XAML,
no binding

viewmodel invocations.  no implicit back
stack.  name + params.  params are checked
and type-checked.  catch errors earlier.

props with origins, merging, fix ordering
and race problems with init vs set

sqlite on the client, of course  :-)

postgres on the server

query server, subscribe to queries

state of each client db instance kept on server

scale out not up

websockets, persistent connections

other plain rest, but same msg format

DI, but plain, no container

testing with a fake implementation of XF

in rxui, everything is a prop first and reflection
is used to make it observable.  WhenAnyValue.  in my
approach, the observable is first-class and the prop
nature is secondary.




