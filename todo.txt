
consider not having ids?  store the content
in the same layout as the site.  directories
are not items.  use file suffix to denote whether
to crunch and/or use template.  everything else
is just copied.

.ehtml

does meta go inside there, or in a separate .emeta file?

link crunching doesn't seem that useful.  although
it does eliminate the problem of a link that goes
nowhere because of a typo.  but this could be
checked differently.

--

the toc entries converted from a script to static
are now using hard-coded links instead of
{{{link:id='n'}}}
which may not be a problem

maybe write script to convert all the entries
to markdown

investigate fornax

investigate md with layout, scss

update style and template

update copyright dates

where is vcbe content?

--

autogen dsl

viewmodels, but maybe not using the term
the way everyone else does.  all rx.

validators

layout completely separate layer

XF but mostly doesn't know, no XAML,
no binding

viewmodel invocations.  no implicit back
stack.  name + params.  params are checked
and type-checked.  catch errors earlier.

props with origins, merging, fix ordering
and race problems with init vs set

sqlite on the client, of course  :-)

postgres on the server

query server, subscribe to queries

state of each client db instance kept on server

scale out not up

websockets, persistent connections

other plain rest, but same msg format

DI, but plain, no container

testing with a fake implementation of XF

in rxui, everything is a prop first and reflection
is used to make it observable.  WhenAnyValue.  in my
approach, the observable is first-class and the prop
nature is secondary.




