
does everything have a datefiled?

specify layout in the front matter like jekyll?
put template.html in a special place?  make sure
gen doesn't copy it over to the output directory.

fix rss generation.  how to get list of
articles?

still need rss?

still need google analytics?

what to do about the print- items?

do we need keywords at all?

teaser?

argument can be made that everything in the esbma.json
file should be salvaged into front matter just in case
we want it later.  maybe even put in the old id?

.ehtml suffix?  or just always look inside .html?

once everything with h is clean, commit c1
to the repo and deploy to s3

link gen does solve the problem of the same
snippet of content being embedded in two different
ways, like in its own page under entries/ but also
in the top index.html, where the relative link
is different.  same problem for rss.  keep ids
for this?  don't pre-crunch after all?

what about ids + paths for images/assets ?
nowhere to put these without an index.json.

fewer issues if all within-site urls are absolute

3 cases:
    /absolute/url
    rel/url/just/sibling/or/child
    ../rel/url/which/goes/up

jekyll doesn't deal with url issues like this, does it?

--

redo front page.  no more complete copies of
recent items.  each item appears on its own page.

responsive:  get rid of sidebar?  just a header
and footer?

link crunching doesn't seem that useful.  although
it does eliminate the problem of a link that goes
nowhere because of a typo.  but this could be
checked differently.

--

the toc entries converted from a script to static
are now using hard-coded links instead of
{{{link:id='n'}}}
which may not be a problem

investigate fornax

update copyright dates

--

autogen dsl

viewmodels, but maybe not using the term
the way everyone else does.  all rx.

validators

layout completely separate layer

XF but mostly doesn't know, no XAML,
no binding

viewmodel invocations.  no implicit back
stack.  name + params.  params are checked
and type-checked.  catch errors earlier.

props with origins, merging, fix ordering
and race problems with init vs set

sqlite on the client, of course  :-)

postgres on the server

query server, subscribe to queries

state of each client db instance kept on server

scale out not up

websockets, persistent connections

other plain rest, but same msg format

DI, but plain, no container

testing with a fake implementation of XF

in rxui, everything is a prop first and reflection
is used to make it observable.  WhenAnyValue.  in my
approach, the observable is first-class and the prop
nature is secondary.


