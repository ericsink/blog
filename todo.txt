
front matter?  or separate .emeta?

--

what to do about the print- items?

--

responsive:  get rid of sidebar?  just a header
and footer?

.ehtml suffix?  or just always look inside .html?

link crunching doesn't seem that useful.  although
it does eliminate the problem of a link that goes
nowhere because of a typo.  but this could be
checked differently.

also, link gen does solve the problem of the same
snippet of content being embedded in two different
ways, like in its own page under entries/ but also
in the top index.html, where the relative link
is different.

--

the toc entries converted from a script to static
are now using hard-coded links instead of
{{{link:id='n'}}}
which may not be a problem

maybe write script to convert all the entries
to markdown

investigate fornax

update style and template

update copyright dates

--

autogen dsl

viewmodels, but maybe not using the term
the way everyone else does.  all rx.

validators

layout completely separate layer

XF but mostly doesn't know, no XAML,
no binding

viewmodel invocations.  no implicit back
stack.  name + params.  params are checked
and type-checked.  catch errors earlier.

props with origins, merging, fix ordering
and race problems with init vs set

sqlite on the client, of course  :-)

postgres on the server

query server, subscribe to queries

state of each client db instance kept on server

scale out not up

websockets, persistent connections

other plain rest, but same msg format

DI, but plain, no container

testing with a fake implementation of XF

in rxui, everything is a prop first and reflection
is used to make it observable.  WhenAnyValue.  in my
approach, the observable is first-class and the prop
nature is secondary.




